# 41EVM存储优化

### 以太坊数据结构树

### 链全局状态

所有的账户的状态集合，都存在链上，具体表现是每一次的交易tx都会刷新状态变量，每一次的emit都会增加Logs的行数

> 全世界所有人的emit都会被其他所有人能查到，都属于上链数据，所以如果你在view函数中，你会发现无法使用emit，因为他虽然不修改状态变量，但依然打包上链

### EVM空间资源分类

把EVM比喻成显示中的电脑

- Storage ≈ EVM 里的「硬盘」：区块链状态存放区，合约的数据永久保留在这里（写入最贵）。
- Memory ≈ EVM 的「内存（RAM）」：函数执行时临时分配的空间，执行完就清空（中等价格）。
- Stack ≈ EVM 的「CPU 寄存器堆」：处理每一步指令时的极小暂存区，只能容纳 1024 项（最快、最小）。
- Transient Storage ≈ EVM 的「临时虚拟磁盘」：函数之间传递资料但不持久写入区块链，执行结束就没了，比 Storage 快也便宜。

| 存储类型              | 是否持久保存 | 生命周期             | 读取/写入成本 | 访问速度 | 容量限制     | 类比（计算机）       | 典型用途                     |
| --------------------- | ------------ | -------------------- | ------------- | -------- | ------------ | -------------------- | ---------------------------- |
| **Storage**           | ✅ 是         | 合约存在期间永久保存 | 非常贵        | 最慢     | 理论无限制   | 硬盘（SSD）          | 保存代币余额、用户数据等状态 |
| **Memory**            | ❌ 否         | 每次函数调用期间     | 中等          | 快       | 理论无限制   | RAM                  | 函数中临时数组、字符串操作等 |
| **Stack**             | ❌ 否         | 每条指令执行期间     | 最便宜        | 非常快   | 1024 个 slot | CPU 寄存器           | 局部变量、指令计算用的暂存值 |
| **Transient Storage** | ❌ 否         | 一次交易执行期间     | 较便宜        | 中等偏快 | 理论无限制   | 临时 RAM 磁盘/缓存区 | 函数之间短期共享数据，不上链 |

## Slot

## Storage Slot 概念和优化

在 Solidity 中，**Storage 是合约的持久化存储区域**，由一个一个大小为 `32 字节` 的单位组成，每个单位称为一个 **slot（槽位）**，就像一个个「抽屉」🗄️。

### 📦 Slot 抽屉类比

| 术语         | 类比             | 说明                                                       |
| ------------ | ---------------- | ---------------------------------------------------------- |
| Storage Slot | 抽屉             | 每个 slot 可存 32 字节（256 位），是存储状态变量的最小单位 |
| 状态变量     | 抽屉中的物品     | 每个变量都会被编译器安排进某个 slot 里                     |
| 打开 slot    | 打开抽屉一次操作 | 读取或写入一个 slot 都会产生 gas 成本                      |
| Slot 编号    | 抽屉编号         | 编译器从 slot 0 开始顺序分配编号                           |

### 一、状态变量定义优化

在 EVM 的世界里，有一排整整齐齐的抽屉，每个抽屉都能放下 32 字节的数据。这些抽屉就是 Storage Slot。

有一天，来了几个变量兄弟，他们准备住进这些抽屉里：

```solidity
uint8 a;
uint8 b;
uint256 c;
```

#### 🧺 故事开始：

 🧍‍♂️ 变量 `a` 是个身材小巧的家伙，只需要 1 字节的空间。
 🧍‍♀️ 变量 `b` 也是个小个子，也只需要 1 字节。

于是编译器管理员说：

> “你俩体积都小，又关系不错（在代码里相邻声明），那就一起住进同一个抽屉 slot 0 吧！”

结果：

- `a` 占据了 slot 0 的第 1 字节
- `b` 占据了 slot 0 的第 2 字节
- 剩下的 30 字节空着，但可以继续给后面的小变量用

然后来了个壮汉 `c`，他是个 `uint256`，需要完整的 32 字节！
 管理员立刻安排他说：

> “你太大了，不能和别人挤，就住在下一个抽屉 slot 1。”

#### ⚡ 优化重点：

- ✅ 把多个小变量（如 `uint8`、`bool`、`address`）**连续声明**，能让它们自动被“打包”进同一个抽屉
- ❗ 若中间插入其他大变量，或者变量分散，编译器就不会打包，浪费抽屉空间
- ✅ 打包后，如果这些变量在同一个函数中一起读写，EVM 只需“打开一次抽屉”，就能同时操作多个变量 → **节省 gas 成本！**

### 二、结构体优化

跟上面抽屉比喻非常类似

#### ⚡ 优化重点：

- ✅ 小变量在结构体中连续声明，可以打包进同一个 slot，节省空间
- ❌ 如果顺序写错了（比如先写 uint256，再写 uint8），每个变量就会被强制分配单独 slot，浪费抽屉
- ✅ 最好的方式是：先放小的，再放大的变量

### 三、动态数据优化

- 在合约中声明的动态变量（如 `string`、`bytes`、`uint[]` 等），它们**在主 storage 中会独占一个 slot**，比如 slot1。

- 但这个 slot **并不直接存数据本体**，而是存一个「指针」信息，**指向实际内容所在的地址**。

- 内容地址是通过：`keccak256(slot编号)`

  得到的，比如 `keccak256(1)` 就是 slot1 对应的数据起始位置。

- 这个地址可以看作是**另一个遥远仓库**，里面可以放很多抽屉（slot），实现动态长度，而且这个遥远仓库永远不会安插在你顺序安排的slot中间，使得你的其他优化存储失败

- 动态数据基本无法在固定逻辑的情况下优化gas，你只能尽量减少操作读写的次数，但是这样却可能破坏了代码逻辑

### 四、固定长数组优化

- 基本没法优化，定长了多少个，就会占有多少个32字节的slot（抽屉）

### 五、string优化

##### 字符与字节的关系简表

| 字符类型   | 字符例子 | 字节数估算 | 说明                      |
| ---------- | -------- | ---------- | ------------------------- |
| 英文字符   | `A`      | 1 字节     | ASCII 范围内，1字符=1字节 |
| 中文字符   | `你`     | 3 字节     | UTF-8编码，一般3字节/字符 |
| Emoji 表情 | `😊`      | 4 字节     | UTF-8编码，通常4字节/字符 |

> 注意：字符串长度是字节数，不是字符数，计算字符串时需按 UTF-8 编码字节数计算。

---

##### 空间优化原则

- **字符串长度 ≤ 31 字节**时，数据和长度会存储在同一个 slot，节省存储空间和 Gas。  
- **字符串长度 > 31 字节**时，数据存放外部槽，slot 只存指针，Gas 较高。  

---

##### 常见场景示例

| 场景                 | 示例字符串                 | 是否 ≤ 31 字节 | 说明                          |
| -------------------- | -------------------------- | -------------- | ----------------------------- |
| ERC20 name/symbol    | `"MyToken"` / `"MTK"`      | 是             | 字符串较短，自动放入同一 slot |
| require 错误信息     | `"Insufficient balance"`   | 一般 ≤ 31      | 短信息自动紧凑存储            |
| 事件参数（备注）     | `"Order submitted"`        | 是             | 自动存储在同一 slot           |
| 长字符串（URL/JSON） | `"https://example.com..."` | 否             | 超长字符串存外部槽，Gas较高   |

---

## 关键点

- 你只能通过控制字符串的 **字节长度** 来影响是否存放在一个 slot。  
- EVM 自动判断并决定数据存储位置。  
- 保持字符串短小（≤31字节）是节省 Gas 的主要手段。  



## Forge中常用的检测命令

#### 一、查看存储布局（看slot怎么安排的）

`forge inspect <合约名> layout [<变量名或函数名>]`

```cmd
> forge inspect Counter layout count
> Storage layout for contract Counter:

| Slot | Variable | Type       | Bytes | Location |
|-------|----------|------------|-------|----------|
| 0     | count    | uint256    | 32    | storage  |
```

#### 二、评估某个函数的gas

`forge inspect <合约名> gas <函数名>`

```cmd
> forge inspect Counter gas increment
> Gas (estimated): 429
```

这个数字表示执行 increment() 函数大概需要 429 gas —— 它是 Foundry 编译器根据当前代码逻辑、状态变量布局等因素静态估算出来的，不是实测运行数据，但一般够你用来对比优化前后的效果。